# g = read.graph("C:\\Users\\rool\\Documents\\My Dropbox\\Education\\Social Network Analysis\\Week 3\\wikipedia.gml",format="gml")
g = read.graph("C:\\users\\charlie_2\\documents\\2013\\000sna\\week04\\wikipedia.gml",format="gml")
# obtain summary information about the graph
summary(g)
# find the maximal k-core any vertex belongs to
graph.coreness(as.undirected(g))
# find the largest clique using cliques(), also making sure the graph is treated as undirected
clique_number(as.undirected(g))
# fastgreedy community finding algorithm
fc = fastgreedy.community(as.undirected(g))
# community sizes
sizes(fc)
# membership in 30th community
V(g)$label[membership(fc)==30]
# InfoMap community finding algorithm (can be slow)
imc = infomap.community(g)
# find the nodes in the largest clique
V(g)$label[largest.cliques(as.undirected(g))[[1]]]
# use modularity() to find the modularity of any given partition
largest_clique(as.undirected(g))
cq = cliques(as.undirected(g))
# Coursera SNA optional Programming Assignment 3 template
# see this blog post for a nice overview of community detection algorithms
# http://www.r-bloggers.com/summary-of-community-detection-algorithms-in-igraph-0-6/
# load the igraph library
# you may have to install this module if you haven't already
library(igraph)
# read in the graph in GML format
# it is a sampled collection of pages from a strange set of seed categories:
# Math, Sociology, and Chemistry
# Change this to be your local file location
#  if you are using Windows, replace the \ in the path with a double \, e.g.
# g = read.graph("C:\\Users\\rool\\Documents\\My Dropbox\\Education\\Social Network Analysis\\Week 3\\wikipedia.gml",format="gml")
g = read.graph("C:\\users\\charlie_2\\documents\\2013\\000sna\\week04\\wikipedia.gml",format="gml")
# obtain summary information about the graph
summary(g)
# find the maximal k-core any vertex belongs to
graph.coreness(as.undirected(g))
# find the largest clique using cliques(), also making sure the graph is treated as undirected
cq = cliques(as.undirected(g))
# fastgreedy community finding algorithm
fc = fastgreedy.community(as.undirected(g))
# community sizes
sizes(fc)
# membership in 30th community
V(g)$label[membership(fc)==30]
# InfoMap community finding algorithm (can be slow)
imc = infomap.community(g)
# find the nodes in the largest clique
V(g)$label[largest.cliques(as.undirected(g))[[1]]]
# use modularity() to find the modularity of any given partition
# Coursera SNA optional Programming Assignment 3 template
# see this blog post for a nice overview of community detection algorithms
# http://www.r-bloggers.com/summary-of-community-detection-algorithms-in-igraph-0-6/
# load the igraph library
# you may have to install this module if you haven't already
library(igraph)
# read in the graph in GML format
# it is a sampled collection of pages from a strange set of seed categories:
# Math, Sociology, and Chemistry
# Change this to be your local file location
#  if you are using Windows, replace the \ in the path with a double \, e.g.
# g = read.graph("C:\\Users\\rool\\Documents\\My Dropbox\\Education\\Social Network Analysis\\Week 3\\wikipedia.gml",format="gml")
g = read.graph("C:\\users\\charlie_2\\documents\\2013\\000sna\\week04\\wikipedia.gml",format="gml")
# obtain summary information about the graph
summary(g)
# find the maximal k-core any vertex belongs to
graph.coreness(as.undirected(g))
# find the largest clique using cliques(), also making sure the graph is treated as undirected
#cq = cliques(as.undirected(g))
# fastgreedy community finding algorithm
fc = fastgreedy.community(as.undirected(g))
# community sizes
sizes(fc)
# membership in 30th community
V(g)$label[membership(fc)==30]
# InfoMap community finding algorithm (can be slow)
imc = infomap.community(g)
# find the nodes in the largest clique
V(g)$label[largest.cliques(as.undirected(g))[[1]]]
# use modularity() to find the modularity of any given partition
imc
modularity(fc)
modularity(imc)
# Coursera SNA optional Programming Assignment 3 template
# see this blog post for a nice overview of community detection algorithms
# http://www.r-bloggers.com/summary-of-community-detection-algorithms-in-igraph-0-6/
# load the igraph library
# you may have to install this module if you haven't already
library(igraph)
# read in the graph in GML format
# it is a sampled collection of pages from a strange set of seed categories:
# Math, Sociology, and Chemistry
# Change this to be your local file location
#  if you are using Windows, replace the \ in the path with a double \, e.g.
# g = read.graph("C:\\Users\\rool\\Documents\\My Dropbox\\Education\\Social Network Analysis\\Week 3\\wikipedia.gml",format="gml")
g = read.graph("C:\\users\\charlie_2\\documents\\2013\\000sna\\week04\\wikipedia.gml",format="gml")
# obtain summary information about the graph
summary(g)
# find the maximal k-core any vertex belongs to
graph.coreness(as.undirected(g))
# find the largest clique using cliques(), also making sure the graph is treated as undirected
#cq = cliques(as.undirected(g))
# fastgreedy community finding algorithm
fc = fastgreedy.community(as.undirected(g))
# community sizes
sizes(fc)
# membership in 30th community
V(g)$label[membership(fc)==30]
# InfoMap community finding algorithm (can be slow)
imc = infomap.community(g)
imc
# find the nodes in the largest clique
V(g)$label[largest.cliques(as.undirected(g))[[1]]]
largest.cliques(as.undirected(g))
# use modularity() to find the modularity of any given partition
modularity(fc)
modularity(imc)
# Coursera SNA optional Programming Assignment 3 template
# see this blog post for a nice overview of community detection algorithms
# http://www.r-bloggers.com/summary-of-community-detection-algorithms-in-igraph-0-6/
# load the igraph library
# you may have to install this module if you haven't already
library(igraph)
# read in the graph in GML format
# it is a sampled collection of pages from a strange set of seed categories:
# Math, Sociology, and Chemistry
# Change this to be your local file location
#  if you are using Windows, replace the \ in the path with a double \, e.g.
# g = read.graph("C:\\Users\\rool\\Documents\\My Dropbox\\Education\\Social Network Analysis\\Week 3\\wikipedia.gml",format="gml")
g = read.graph("C:\\users\\charlie_2\\documents\\2013\\000sna\\week04\\wikipedia.gml",format="gml")
# obtain summary information about the graph
summary(g)
# find the maximal k-core any vertex belongs to
graph.coreness(as.undirected(g))
# find the largest clique using cliques(), also making sure the graph is treated as undirected
#cq = cliques(as.undirected(g))
# fastgreedy community finding algorithm
fc = fastgreedy.community(as.undirected(g))
# community sizes
sizes(fc)
# membership in 30th community
V(g)$label[membership(fc)==30]
# InfoMap community finding algorithm (can be slow)
imc = infomap.community(g)
#imc
# find the nodes in the largest clique
V(g)$label[largest.cliques(as.undirected(g))[[1]]]
# use modularity() to find the modularity of any given partition
modularity(fc)
modularity(imc)
# find the nodes in the largest clique
lc = largest.cliques(as.undirected(g))
V(g)$label[lc[[1]]]
V(g)$label[lc[[1]]]
V(g)$size[lc]
V(g)$size[lc[[1]]]
kc = graph.coreness(as.undirected(g))
V(g)$label[kc[[1]]]
V(g)$label[lc[[1]]]
V(g)$label[kc]
kc = graph.coreness(as.undirected(g))
kc
whic.max(kc)
which.max(kc)
19.39/8*3600/1024
a <- available.packages()
head(rownames(a),3)
install.packages("slidify")
a <- available.packages()
head(rownames(a), 3)
install.packages("slidify","ggplot2","devtools")
install.packages("slidify")
install.packages(ggplot2","devtools")
install.packages("ggplot2","devtools")
install.packages(ggplot2","devtools")
install.packages("ggplot2","devtools")
library(ggplot2)
search()
library(devtools)
library(devtool)
library(devtools)
install.packages(devtools")
)
""
install.packages("devtools")
find.packages("devtools")
find.package("devtools")
find.package("slidify")
library(devtools)
search()
find_rtools()
install.packages("KernSmooth")
remove.packages(KernSmooth)
library KernSmooth
library(KernSmooth)
pwd
demo()
install.packages("swirl")
library("swirl")
swirl()
getwd()
ls()
library(swirl)
rm(list=ls())
exi
exit
x <- as.date("1970-01-01)
""
)
""
x <- as.date("1970-01-01")
x <- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02")
)
unclass(as.Date("1970-01-02"))
x <- Sys.time()
x
p <- as.POSIXlt(x)
name(uncless(p))
name(unclass(p))
names(unclass(p))
p$zone
p$yday
p$sec
p$mday
p$month
p$mon
p$year
p$sec
p$sec
p$sec
x <- Sys.time()
x
unclass(x)
x$sec
p <- as.POSIClt(x)
p <- as.POSIXlt(x)
p$sec
datestring <- c("January 10, 2012 10:40", "December 9, 2011, 9:10")
x <-strptime(datestring, $B $d %Y %H:%M"")
x <-strptime(datestring, %B %d %Y %H:%M"")
x <-strptime(datestring, "%B %d %Y %H:%M"")
x
)
)
""
x <-strptime(datestring, %B %d %Y %H:%M")
x <-strptime(datestring, "%B %d %Y %H:%M")
x
datestring
class(x)
x <-strptime(datestring, "%B %d %Y %H:%M"")
)
""
x <-strptime(datestring, "%B %d %Y %H:%M")
x
x <- strptime(datestring, "%B %d, %Y %H:%M")
x
datestring <- c("January 10, 2012 10:40", "December 9, 2011 9:10")
x <- strptime(datestring, "%B %d, %Y %H:%M")
x
x <- as.Date("2012-01-01")
y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %H:%M:%S")
x-y
x
y
x <- as.POSIXlt(x)
x
x - y
x <- list(a = 1:5, b = rnorm(10))
x
lapply(x, mean)
x <- list(a = 1:4, b = rnorm(10), c=rnorm(20,1), d=rnorm(100,5))
x
lapply(x, mean)
x <- 1:4
lapply(x, runif)
lapply(x, runif, min=0, max=10)
x <- list(a=matrix(1:4,2,2), b=matrix(1:6,3,2))
x
lapply(x, function(elt) elt[,1])
elt
function(elt) elt([,1])
x <- list(a = 1:4, b = rnorm(10), c=rnorm(20,1), d=rnorm(100,5))
lapply(x, mean)
sapply(x,mean)
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
apply(x, 1, sum)
x <- matrix(rnorm(100), 20, 10)
apply(x, 1, quantile, probs=c(0.25, 0.75))
a <- array(rnorm(40), c(2,2,10))
a
apply(a, c(1,2), mean)
apply(a, 3, mean)
rowmeans(a, dims=2)
rowMeans(a, dims=2)
?rowMeans
?rowMean
?rowmean
??rowmean
list(rep(1, 4), rep(2, 3), rep(3,2), rep(4,1))
mapply(rep, 1:4, 4:1)
noise <- function(n, mean, sd) {}
rnorm(n, mean, sd)
noise <- function(n, mean, sd) {
rnorm(n, mean, sd)
}
noise(5,1,2)
mapply(noise, 1:5, 1:5, 2)
?factor
x <- c(rnorm(10), runif(10), rnorm(10,1))
x
f <- gl(3, 10)
f
?gl
tapply(x, f, mean)
str(split)
?str
split(x, f)
x[f==1]
x[f==2]
lapply(split(x,f), mean)
tapply(x, f, mean)
library(datasets)
head(airquality)
split(airquality, month)
split(airquality, airquality$Month)
s <- split(airquality, airquality$Month)
lapply(s, fuctin(x) colMeans[x[, c("Ozone", "Solar.R", "Wind")]])
lapply(s, fuctin(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")])
lapply(s, fuctin(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
lapply(s, fuction(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
lapply(s, fuction(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
lapply(s, fuction(x), colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
lapply(s, fuction(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
s
lapply(s, fuction(x) colMeans(x[ , c("Ozone", "Solar.R", "Wind")]))
c("Ozone", "Solar.R", "Wind")
f <- c("Ozone", "Solar.R", "Wind")
lapply(s, fuction(x) colMeans(x[f]))
lapply(s, fuction(x) colMeans(x[f]))
ls(colMeans)
colMeans
rm(colMeans)
lapply(s, colMeans(x[f]))
s
lapply(mean, s)
s <- split(airquality, airquality$Month)
lapply(s)
lapply(s, colMeans)
rm(colMeans)
lapply(s, fuction(x) colMeans(x[,1:5]))
lapply(s, fuction(x) colMeans(x[, 1:4]))
lapply(s, fuction(x) colMeans(x[, 1:3]))
lapply(s, fuction(x) colMeans(x[,1]))
lapply(s, fuction(x) colMeans(x[,1:2]))
s[, f]
s[, c("Ozone", "Solar.R", "Wind")]
s[1, c("Ozone", "Solar.R", "Wind")]
s
split(airquality, airquality$Month)
split(airquality, airquality$Month, simplify=TRUE)
split(airquality, airquality$Month)
head(airquality)
split(airquality, airquality$Month)
airquality$Month
class(airquality)
split(airquality, airquality$Month)
s <- split(airquality, airquality$Month)
s
class(s)
?lapply
colMeans[s]
colMeans(s)
s[1,1]
s[[1]]
lapply(s, fuction(x) colMeans(x[[],1:2]))
colMeans(s$`5`)
s5 <- s$'5'
s5
colmeans(s5[, c("Ozone", "Solar.R", ":Wind"])
colmeans(s5[, c("Ozone", "Solar.R", ":Wind")])
colMeans(s5[, c("Ozone", "Solar.R", ":Wind")])
colMeans(s5[, c("Ozone", "Solar.R", "Wind")])
s <- as.list(split(airquality, airquality$Month))
s
lapply(s, colMeans
)
lapply(s, function(tt) colMeans(tt[, c("Ozone", "Solar.R", "Wind")]))
x
rm(x)
lapply(s, fuction(x) colMeans(x[ , c("Ozone", "Solar.R", "Wind")]))
lapply(s, function(x) colMeans(x[ , c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[ , c("Ozone", "Solar.R", "Wind")]))
z <- sapply(s, function(x) colMeans(x[ , c("Ozone", "Solar.R", "Wind")]))
class(z)
sapply(s, function(x) colMeans(x[ , c("Ozone", "Solar.R", "Wind")], na.rm=T))
x <- rnorm(10)
f1 <- gl(2,5)
f1
f2 <- gl(5,2)
f2
interaction(f1, f2)
split(x, interaction(f1, f2))
str(split(x, list(f1, f2)))
split(x, list(f1, f2))
split(x, list(f1, f2), drop=T)
c(T, T) && c(F, T)
if(c(T, T) && c(F, T)) {}
if(c(T, T) && c(F, T)) {}
log(-1)
printmessage <- function(x) {}
printmessage <- function(x) {}
printmessage <- function(x) {
if(x>0)
print("x is greater than zero")
else
print("x is less than zero")
invisible(x)
}
printmessage(2)
printmessage(-1)
print("hello world")
xx <- print("hello world")
xx
printmessage(NA)
printmessage <- function(x) {
if (is.na(x))
print("x is a missing value!")
else if(x>0)
print("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x)
}
printmessage(NA)
mean(x)
rm(x)
mean(x)
traceback()
rm(y)
lm(y ~ x)
traceback()
?~
~
''
debug(lm)
lm(y ~ x)
exit
options(error = recover)
read.csv("nosuchfile")
exit
ls()
rm(ls())
options(error = stop)
rm(ls())
rm(x)
rm(y)
rm(p)
library(datasets)
data(iris)
?iris
iri
iris
split(iris, iris$species)
split(iris, iris$Species)
s <- split(iris, iris$Species)
s
s$virginica
vir <- s[["virginica"]]
vir
colMeans(vir)
colMeans(vir$Sepal.Length)
vir$Sepal.Length
mean(vir$Sepal.Length)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 1, mean)
rowMeans(iris[, 1:4])
apply(iris, 1, mean)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
mtcars
apply(mtcars, 2, mean)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$cyl, mtcars$mpg, mean)
lapply(mtcars, mean)
with(mtcars, tapply(mpg, cyl, mean))
tapply(mpg, cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
with(mtcars, tapply(hp, cyl, mean))
avg_hp <- with(mtcars, tapply(hp, cyl, mean))
abs(avg_hp$8 - avg+hp$4)
abs(avg_hp$8 - avg_hp$4)
avg_hp$8 - avg_hp$4
avg_hp$8
avg_hp$'8'
avg_hp
class(avg_hp)
avg_hp[3]
avg_hp[3] - avg_hp[1]
debug(ls)
ls()
exit
q
exit
setwd("C:/Users/Charlie_2/ProgrammingAssignment2/ProgrammingAssignment2")
